 include/Makefile.am                                |   2 +-
 libffi.pc.in                                       |   5 +-
 src/aarch64/ffi.c                                  |   2 +-
 src/or1k/ffi.c                                     | 328 -----------------
 src/or1k/ffitarget.h                               |  58 ---
 src/or1k/sysv.S                                    | 107 ------
 src/powerpc/linux64_closure.S.orig                 | 391 ---------------------
 testsuite/libffi.call/cls_align_complex.inc        |  91 -----
 testsuite/libffi.call/cls_align_complex_double.c   |  10 -
 testsuite/libffi.call/cls_align_complex_float.c    |  10 -
 .../libffi.call/cls_align_complex_longdouble.c     |  10 -
 testsuite/libffi.call/cls_complex.inc              |  42 ---
 testsuite/libffi.call/cls_complex_double.c         |  10 -
 testsuite/libffi.call/cls_complex_float.c          |  10 -
 testsuite/libffi.call/cls_complex_longdouble.c     |  10 -
 testsuite/libffi.call/cls_complex_struct.inc       |  71 ----
 testsuite/libffi.call/cls_complex_struct_double.c  |  10 -
 testsuite/libffi.call/cls_complex_struct_float.c   |  10 -
 .../libffi.call/cls_complex_struct_longdouble.c    |  10 -
 testsuite/libffi.call/cls_complex_va.inc           |  80 -----
 testsuite/libffi.call/cls_complex_va_double.c      |  10 -
 testsuite/libffi.call/cls_complex_va_float.c       |  10 -
 testsuite/libffi.call/cls_complex_va_longdouble.c  |  10 -
 testsuite/libffi.call/complex.inc                  |  51 ---
 testsuite/libffi.call/complex_defs_double.inc      |   7 -
 testsuite/libffi.call/complex_defs_float.inc       |   7 -
 testsuite/libffi.call/complex_defs_longdouble.inc  |   7 -
 testsuite/libffi.call/complex_double.c             |  10 -
 testsuite/libffi.call/complex_float.c              |  10 -
 testsuite/libffi.call/complex_int.c                |  86 -----
 testsuite/libffi.call/complex_longdouble.c         |  10 -
 testsuite/libffi.call/many_complex.inc             |  78 ----
 testsuite/libffi.call/many_complex_double.c        |  10 -
 testsuite/libffi.call/many_complex_float.c         |  10 -
 testsuite/libffi.call/many_complex_longdouble.c    |  10 -
 testsuite/libffi.call/return_complex.inc           |  37 --
 testsuite/libffi.call/return_complex1.inc          |  41 ---
 testsuite/libffi.call/return_complex1_double.c     |  10 -
 testsuite/libffi.call/return_complex1_float.c      |  10 -
 testsuite/libffi.call/return_complex1_longdouble.c |  10 -
 testsuite/libffi.call/return_complex2.inc          |  40 ---
 testsuite/libffi.call/return_complex2_double.c     |  10 -
 testsuite/libffi.call/return_complex2_float.c      |  10 -
 testsuite/libffi.call/return_complex2_longdouble.c |  10 -
 testsuite/libffi.call/return_complex_double.c      |  10 -
 testsuite/libffi.call/return_complex_float.c       |  10 -
 testsuite/libffi.call/return_complex_longdouble.c  |  10 -
 47 files changed, 4 insertions(+), 1797 deletions(-)

diff --git a/include/Makefile.am b/include/Makefile.am
index fd28024..15301d6 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -5,5 +5,5 @@ AUTOMAKE_OPTIONS=foreign
 DISTCLEANFILES=ffitarget.h
 EXTRA_DIST=ffi.h.in ffi_common.h
 
-includesdir = $(libdir)/@PACKAGE_NAME@-@PACKAGE_VERSION@/include
+includesdir = $(includedir)
 nodist_includes_HEADERS = ffi.h ffitarget.h
diff --git a/libffi.pc.in b/libffi.pc.in
index edf6fde..7695266 100644
--- a/libffi.pc.in
+++ b/libffi.pc.in
@@ -1,11 +1,10 @@
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 libdir=@libdir@
-toolexeclibdir=@toolexeclibdir@
-includedir=${libdir}/@PACKAGE_NAME@-@PACKAGE_VERSION@/include
+includedir=@includedir@
 
 Name: @PACKAGE_NAME@
 Description: Library supporting Foreign Function Interfaces
 Version: @PACKAGE_VERSION@
-Libs: -L${toolexeclibdir} -lffi
+Libs: -L${libdir} -lffi
 Cflags: -I${includedir}
diff --git a/src/aarch64/ffi.c b/src/aarch64/ffi.c
index cdb7816..d15e71d 100644
--- a/src/aarch64/ffi.c
+++ b/src/aarch64/ffi.c
@@ -731,7 +731,7 @@ aarch64_prep_args (struct call_context *context, unsigned char *stack,
 	      state.ngrn = N_X_ARG_REG;
 
 	      memcpy (allocate_to_stack (&state, stack, ty->alignment,
-					 ty->size), ecif->avalue + i, ty->size);
+					 ty->size), ecif->avalue[i], ty->size);
 	    }
 	  break;
 
diff --git a/src/or1k/ffi.c b/src/or1k/ffi.c
deleted file mode 100644
index 2bad938..0000000
--- a/src/or1k/ffi.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/* -----------------------------------------------------------------------
-   ffi.c - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>
-
-   OpenRISC Foreign Function Interface
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-   DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-
-#include <ffi.h>
-#include "ffi_common.h"
-
-/* ffi_prep_args is called by the assembly routine once stack space
-   has been allocated for the function's arguments */
-
-void* ffi_prep_args(char *stack, extended_cif *ecif)
-{
-  char *stacktemp = stack;
-  int i, s;
-  ffi_type **arg;
-  int count = 0;
-  int nfixedargs;
-  
-  nfixedargs = ecif->cif->nfixedargs;
-  arg = ecif->cif->arg_types;
-  void **argv = ecif->avalue;
-
-  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT)
-    {
-      *(void **) stack = ecif->rvalue;
-      stack += 4;
-      count = 4;
-    } 
-  for(i=0; i<ecif->cif->nargs; i++)
-  {
-
-    /* variadic args are saved on stack */
-    if ((nfixedargs == 0) && (count < 24))
-      {
-        count = 24;
-        stack = stacktemp + 24;        
-      }
-    nfixedargs--;
-
-    s = 4;
-    switch((*arg)->type) 
-      {
-      case FFI_TYPE_STRUCT:
-        *(void **)stack = *argv;
-        break;
-
-      case FFI_TYPE_SINT8:
-        *(signed int *) stack = (signed int)*(SINT8 *)(* argv);
-        break;
-
-      case FFI_TYPE_UINT8:
-        *(unsigned int *) stack = (unsigned int)*(UINT8 *)(* argv);
-        break;
-
-      case FFI_TYPE_SINT16:
-        *(signed int *) stack = (signed int)*(SINT16 *)(* argv);
-        break;
-
-      case FFI_TYPE_UINT16:
-        *(unsigned int *) stack = (unsigned int)*(UINT16 *)(* argv);
-        break;
-
-      case FFI_TYPE_SINT32:
-      case FFI_TYPE_UINT32:
-      case FFI_TYPE_FLOAT:
-      case FFI_TYPE_POINTER:
-        *(int *)stack = *(int*)(*argv);
-        break;
-
-      default: /* 8 byte types */
-        if (count == 20) /* never split arguments */
-          {
-            stack += 4;
-            count += 4;
-          }  
-        s = (*arg)->size;
-        memcpy(stack, *argv, s);
-        break;
-      }
-
-    stack += s;
-    count += s;
-    argv++;
-    arg++;
-  }
-  return stacktemp + ((count>24)?24:0);
-}
-
-extern void ffi_call_SYSV(unsigned,
-                          extended_cif *,
-                          void *(*)(int *, extended_cif *),
-                          unsigned *,
-                          void (*fn)(void),
-                          unsigned);
-
-
-void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
-{
-  int i;
-  int size;
-  ffi_type **arg;
-
-  /* Calculate size to allocate on stack */
-
-  for(i = 0, arg = cif->arg_types, size=0; i < cif->nargs; i++, arg++)
-    {
-      if ((*arg)->type == FFI_TYPE_STRUCT)
-        size += 4;
-      else
-      if ((*arg)->size <= 4)
-        size += 4;
-      else
-        size += 8;
-    }
-
-  /* for variadic functions more space is needed on the stack */
-  if (cif->nargs != cif->nfixedargs)
-    size += 24;
-
-  if (cif->rtype->type == FFI_TYPE_STRUCT)
-    size += 4;
-
-
-  extended_cif ecif;
-  ecif.cif = cif;
-  ecif.avalue = avalue;
-  ecif.rvalue = rvalue;
-
-  switch (cif->abi) 
-  {
-    case FFI_SYSV:
-      ffi_call_SYSV(size, &ecif, ffi_prep_args, rvalue, fn, cif->flags);
-      break;
-    default:
-      FFI_ASSERT(0);
-      break;
-  }
-}
-
-
-void ffi_closure_SYSV(unsigned long r3, unsigned long r4, unsigned long r5, 
-                      unsigned long r6, unsigned long r7, unsigned long r8)
-{
-  register int *sp __asm__ ("r17");
-  register int *r13 __asm__ ("r13");
-
-  ffi_closure* closure = (ffi_closure*) r13;
-  char *stack_args = sp;
-
-  /* Lay the register arguments down in a continuous chunk of memory.  */
-  unsigned register_args[6] =
-    { r3, r4, r5, r6, r7, r8 };
-
-  /* Pointer to a struct return value.  */
-  void *struct_rvalue = (void *) r3;
-
-  ffi_cif *cif = closure->cif;
-  ffi_type **arg_types = cif->arg_types;
-  void **avalue = alloca (cif->nargs * sizeof(void *));
-  char *ptr = (char *) register_args;
-  int count = 0;
-  int nfixedargs = cif->nfixedargs;
-  int i;
-
-  /* preserve struct type return pointer passing */
-
-  if ((cif->rtype != NULL) && (cif->rtype->type == FFI_TYPE_STRUCT)) 
-  {
-    ptr += 4;
-    count = 4;
-  }
-
-  /* Find the address of each argument.  */
-  for (i = 0; i < cif->nargs; i++)
-    {
-
-      /* variadic args are saved on stack */
-      if ((nfixedargs == 0) && (count < 24))
-        {
-          ptr = stack_args;
-          count = 24;
-        }
-      nfixedargs--;
-
-      switch (arg_types[i]->type)
-        {
-        case FFI_TYPE_SINT8:
-        case FFI_TYPE_UINT8:
-          avalue[i] = ptr + 3;
-          break;
-
-        case FFI_TYPE_SINT16:
-        case FFI_TYPE_UINT16:
-          avalue[i] = ptr + 2;
-          break;
-
-        case FFI_TYPE_SINT32:
-        case FFI_TYPE_UINT32:
-        case FFI_TYPE_FLOAT:
-        case FFI_TYPE_POINTER:
-          avalue[i] = ptr;
-          break;
-
-        case FFI_TYPE_STRUCT:
-          avalue[i] = *(void**)ptr;
-          break;
-
-        default:
-          /* 8-byte values  */
-
-          /* arguments are never splitted */
-          if (ptr == &register_args[5])
-            ptr = stack_args;
-          avalue[i] = ptr;
-          ptr += 4;
-          count += 4;
-          break;
-        }
-      ptr += 4;
-      count += 4;
-
-      /* If we've handled more arguments than fit in registers,
-         start looking at the those passed on the stack.  */
-
-      if (count == 24)
-        ptr = stack_args;
-    }
-
-  if (cif->rtype && (cif->rtype->type == FFI_TYPE_STRUCT))
-    {
-      (closure->fun) (cif, struct_rvalue, avalue, closure->user_data);
-    } else
-    {
-      long long rvalue;
-      (closure->fun) (cif, &rvalue, avalue, closure->user_data);
-      if (cif->rtype)
-        asm ("l.ori r12, %0, 0x0\n l.lwz r11, 0(r12)\n l.lwz r12, 4(r12)" : : "r" (&rvalue));      
-    }
-}
-
-
-ffi_status
-ffi_prep_closure_loc (ffi_closure* closure,
-                      ffi_cif* cif,
-                      void (*fun)(ffi_cif*,void*,void**,void*),
-                      void *user_data,
-                      void *codeloc)
-{
-  unsigned short *tramp = (unsigned short *) closure->tramp;
-  unsigned long fn = (unsigned long) ffi_closure_SYSV;
-  unsigned long cls = (unsigned long) codeloc;
-
-  if (cif->abi != FFI_SYSV)
-    return FFI_BAD_ABI;
-
-  closure->cif = cif;
-  closure->user_data = user_data;
-  closure->fun = fun;
-
-  /* write pointers to temporary registers */
-  tramp[0] = (0x6 << 10) | (13 << 5); /* l.movhi r13, ... */
-  tramp[1] = cls >> 16;
-  tramp[2] = (0x2a << 10) | (13 << 5) | 13; /* l.ori r13, r13, ... */
-  tramp[3] = cls & 0xFFFF;
-
-  tramp[4] = (0x6 << 10) | (15 << 5); /* l.movhi r15, ... */
-  tramp[5] = fn >> 16;
-  tramp[6] = (0x2a << 10) | (15 << 5) | 15; /* l.ori r15, r15 ... */
-  tramp[7] = fn & 0xFFFF;
-
-  tramp[8] = (0x11 << 10); /* l.jr r15 */
-  tramp[9] = 15 << 11;
-
-  tramp[10] = (0x2a << 10) | (17 << 5) | 1; /* l.ori r17, r1, ... */
-  tramp[11] = 0x0;
-
-  return FFI_OK;
-}
-
-
-ffi_status ffi_prep_cif_machdep (ffi_cif *cif)
-{
-  cif->flags = 0;
-	
-  /* structures are returned as pointers */
-  if (cif->rtype->type == FFI_TYPE_STRUCT)
-    cif->flags = FFI_TYPE_STRUCT;
-  else 
-  if (cif->rtype->size > 4)
-    cif->flags = FFI_TYPE_UINT64;
-
-  cif->nfixedargs = cif->nargs;
-
-  return FFI_OK;
-}
-
-
-ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,
-         unsigned int nfixedargs, unsigned int ntotalargs)
-{
-  ffi_status status;
-
-  status = ffi_prep_cif_machdep (cif);
-  cif->nfixedargs = nfixedargs;
-  return status;
-} 
diff --git a/src/or1k/ffitarget.h b/src/or1k/ffitarget.h
deleted file mode 100644
index e55da28..0000000
--- a/src/or1k/ffitarget.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -----------------------------------------------------------------------
-   ffitarget.h - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>
-
-   OpenRISC Target configuration macros
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-   DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-
-#ifndef LIBFFI_TARGET_H
-#define LIBFFI_TARGET_H
-
-#ifndef LIBFFI_H
-#error "Please do not include ffitarget.h directly into your source. Use ffi.h instead."
-#endif
-
-/* ---- System specific configurations ----------------------------------- */
-
-#ifndef LIBFFI_ASM
-typedef unsigned long          ffi_arg;
-typedef signed long            ffi_sarg;
-
-typedef enum ffi_abi {
-  FFI_FIRST_ABI = 0,
-  FFI_SYSV,
-  FFI_LAST_ABI,
-  FFI_DEFAULT_ABI = FFI_SYSV
-} ffi_abi;
-#endif
-
-/* ---- Definitions for closures ----------------------------------------- */
-
-#define FFI_CLOSURES 1
-#define FFI_NATIVE_RAW_API 0
-#define FFI_TRAMPOLINE_SIZE (24)
-
-#define FFI_TARGET_SPECIFIC_VARIADIC 1
-#define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs;
-
-#endif
-
diff --git a/src/or1k/sysv.S b/src/or1k/sysv.S
deleted file mode 100644
index df6570b..0000000
--- a/src/or1k/sysv.S
+++ /dev/null
@@ -1,107 +0,0 @@
-/* -----------------------------------------------------------------------
-   sysv.S - Copyright (c) 2014 Sebastian Macke <sebastian@macke.de>
-
-   OpenRISC Foreign Function Interface
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-   DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-
-#define LIBFFI_ASM
-#include <fficonfig.h>
-#include <ffi.h>
-
-.text
-	.globl ffi_call_SYSV
-	.type ffi_call_SYSV, @function
-/*
-  r3: size to allocate on stack
-  r4: extended cif structure
-  r5: function pointer ffi_prep_args
-  r6: ret address
-  r7: function to call
-  r8: flag for return type
-*/
-
-ffi_call_SYSV:
-	/* Store registers used on stack */
-	l.sw -4(r1), r9 /* return address */
-	l.sw -8(r1), r1 /* stack address */
-	l.sw -12(r1), r14 /* callee saved registers */
-	l.sw -16(r1), r16
-	l.sw -20(r1), r18 
-	l.sw -24(r1), r20
-
-	l.ori r14, r1, 0x0 /* save stack pointer */
-	l.addi r1, r1, -24
-
-	l.ori r16, r7, 0x0 /* save function address */
-	l.ori r18, r6, 0x0 /* save ret address */
-	l.ori r20, r8, 0x0 /* save flag */
-
-	l.sub r1, r1, r3 /* reserve space on stack */
-
-	/* Call ffi_prep_args */
-	l.ori r3, r1, 0x0  /* first argument stack address, second already ecif */
-	l.jalr r5
-	l.nop
-
-	/* Load register arguments and call*/
-
-	l.lwz r3, 0(r1)
-	l.lwz r4, 4(r1)
-	l.lwz r5, 8(r1)
-	l.lwz r6, 12(r1)
-	l.lwz r7, 16(r1)
-	l.lwz r8, 20(r1)
-	l.ori r1, r11, 0x0 /* new stack pointer */
-	l.jalr r16
-	l.nop
-	
-	/* handle return values */
-
-	l.sfeqi r20, FFI_TYPE_STRUCT
-	l.bf ret  /* structs don't return an rvalue */
-	l.nop
-
-	/* copy ret address */
-
-	l.sfeqi r20, FFI_TYPE_UINT64
-	l.bnf four_byte_ret  /* 8 byte value is returned */
-	l.nop
-
-	l.sw 4(r18), r12
-
-four_byte_ret:
-	l.sw 0(r18), r11
-
-ret:
-	/* return */
-	l.ori r1, r14, 0x0 /* reset stack pointer */
-	l.lwz r9, -4(r1)
-	l.lwz r1, -8(r1)
-	l.lwz r14, -12(r1)
-	l.lwz r16, -16(r1)
-	l.lwz r18, -20(r1)
-	l.lwz r20, -24(r1)
-	l.jr r9
-	l.nop
-
-.size ffi_call_SYSV, .-ffi_call_SYSV
diff --git a/src/powerpc/linux64_closure.S.orig b/src/powerpc/linux64_closure.S.orig
deleted file mode 100644
index bc61b5e..0000000
--- a/src/powerpc/linux64_closure.S.orig
+++ /dev/null
@@ -1,391 +0,0 @@
-/* -----------------------------------------------------------------------
-   sysv.h - Copyright (c) 2003 Jakub Jelinek <jakub@redhat.com>
-	    Copyright (c) 2008 Red Hat, Inc.
-
-   PowerPC64 Assembly glue.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   ``Software''), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be included
-   in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-   DEALINGS IN THE SOFTWARE.
-   ----------------------------------------------------------------------- */
-#define LIBFFI_ASM
-#include <fficonfig.h>
-#include <ffi.h>
-
-	.file	"linux64_closure.S"
-
-#ifdef POWERPC64
-	FFI_HIDDEN (ffi_closure_LINUX64)
-	.globl  ffi_closure_LINUX64
-# if _CALL_ELF == 2
-	.text
-ffi_closure_LINUX64:
-	addis	%r2, %r12, .TOC.-ffi_closure_LINUX64@ha
-	addi	%r2, %r2, .TOC.-ffi_closure_LINUX64@l
-	.localentry ffi_closure_LINUX64, . - ffi_closure_LINUX64
-# else
-	.section        ".opd","aw"
-	.align  3
-ffi_closure_LINUX64:
-#  ifdef _CALL_LINUX
-	.quad   .L.ffi_closure_LINUX64,.TOC.@tocbase,0
-	.type   ffi_closure_LINUX64,@function
-	.text
-.L.ffi_closure_LINUX64:
-#  else
-	FFI_HIDDEN (.ffi_closure_LINUX64)
-	.globl  .ffi_closure_LINUX64
-	.quad   .ffi_closure_LINUX64,.TOC.@tocbase,0
-	.size   ffi_closure_LINUX64,24
-	.type   .ffi_closure_LINUX64,@function
-	.text
-.ffi_closure_LINUX64:
-#  endif
-# endif
-
-# if _CALL_ELF == 2
-#  32 byte special reg save area + 64 byte parm save area
-#  + 64 byte retval area + 13*8 fpr save area + round to 16
-#  define STACKFRAME 272
-#  define PARMSAVE 32
-#  define RETVAL PARMSAVE+64
-# else
-#  48 bytes special reg save area + 64 bytes parm save area
-#  + 16 bytes retval area + 13*8 bytes fpr save area + round to 16
-#  define STACKFRAME 240
-#  define PARMSAVE 48
-#  define RETVAL PARMSAVE+64
-# endif
-
-.LFB1:
-# if _CALL_ELF == 2
-	ld	%r12, FFI_TRAMPOLINE_SIZE(%r11)		# closure->cif
-	mflr	%r0
-	lwz	%r12, 28(%r12)				# cif->flags
-	mtcrf	0x40, %r12
-	addi	%r12, %r1, PARMSAVE
-	bt	7, .Lparmsave
-	# Our caller has not allocated a parameter save area.
-	# We need to allocate one here and use it to pass gprs to
-	# ffi_closure_helper_LINUX64.
-	addi	%r12, %r1, -STACKFRAME+PARMSAVE
-.Lparmsave:
-	std	%r0, 16(%r1)
-	# Save general regs into parm save area
-	std	%r3, 0(%r12)
-	std	%r4, 8(%r12)
-	std	%r5, 16(%r12)
-	std	%r6, 24(%r12)
-	std	%r7, 32(%r12)
-	std	%r8, 40(%r12)
-	std	%r9, 48(%r12)
-	std	%r10, 56(%r12)
-
-	# load up the pointer to the parm save area
-	mr	%r5, %r12
-# else
-	# copy r2 to r11 and load TOC into r2
-	mr	%r11, %r2
-	ld	%r2, 16(%r11)
-
-	mflr	%r0
-	# Save general regs into parm save area
-	# This is the parameter save area set up by our caller.
-	std	%r3, PARMSAVE+0(%r1)
-	std	%r4, PARMSAVE+8(%r1)
-	std	%r5, PARMSAVE+16(%r1)
-	std	%r6, PARMSAVE+24(%r1)
-	std	%r7, PARMSAVE+32(%r1)
-	std	%r8, PARMSAVE+40(%r1)
-	std	%r9, PARMSAVE+48(%r1)
-	std	%r10, PARMSAVE+56(%r1)
-
-	std	%r0, 16(%r1)
-
-	# load up the pointer to the parm save area
-	addi	%r5, %r1, PARMSAVE
-# endif
-
-	# next save fpr 1 to fpr 13
-	stfd	%f1, -104+(0*8)(%r1)
-	stfd	%f2, -104+(1*8)(%r1)
-	stfd	%f3, -104+(2*8)(%r1)
-	stfd	%f4, -104+(3*8)(%r1)
-	stfd	%f5, -104+(4*8)(%r1)
-	stfd	%f6, -104+(5*8)(%r1)
-	stfd	%f7, -104+(6*8)(%r1)
-	stfd	%f8, -104+(7*8)(%r1)
-	stfd	%f9, -104+(8*8)(%r1)
-	stfd	%f10, -104+(9*8)(%r1)
-	stfd	%f11, -104+(10*8)(%r1)
-	stfd	%f12, -104+(11*8)(%r1)
-	stfd	%f13, -104+(12*8)(%r1)
-
-	# load up the pointer to the saved fpr registers */
-	addi	%r6, %r1, -104
-
-	# load up the pointer to the result storage
-	addi	%r4, %r1, -STACKFRAME+RETVAL
-
-	stdu	%r1, -STACKFRAME(%r1)
-.LCFI0:
-
-	# get the context pointer from the trampoline
-	mr	%r3, %r11
-
-	# make the call
-# if defined _CALL_LINUX || _CALL_ELF == 2
-	bl ffi_closure_helper_LINUX64
-# else
-	bl .ffi_closure_helper_LINUX64
-# endif
-.Lret:
-
-	# now r3 contains the return type
-	# so use it to look up in a table
-	# so we know how to deal with each type
-
-	# look up the proper starting point in table
-	# by using return type as offset
-	ld %r0, STACKFRAME+16(%r1)
-	cmpldi %r3, FFI_V2_TYPE_SMALL_STRUCT
-	bge .Lsmall
-	mflr %r4		# move address of .Lret to r4
-	sldi %r3, %r3, 4	# now multiply return type by 16
-	addi %r4, %r4, .Lret_type0 - .Lret
-	add %r3, %r3, %r4	# add contents of table to table address
-	mtctr %r3
-	bctr			# jump to it
-
-# Each of the ret_typeX code fragments has to be exactly 16 bytes long
-# (4 instructions). For cache effectiveness we align to a 16 byte boundary
-# first.
-	.align 4
-
-.Lret_type0:
-# case FFI_TYPE_VOID
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-	nop
-# case FFI_TYPE_INT
-# ifdef __LITTLE_ENDIAN__
-	lwa %r3, RETVAL+0(%r1)
-# else
-	lwa %r3, RETVAL+4(%r1)
-# endif
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_FLOAT
-	lfs %f1, RETVAL+0(%r1)
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_DOUBLE
-	lfd %f1, RETVAL+0(%r1)
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_LONGDOUBLE
-	lfd %f1, RETVAL+0(%r1)
-	mtlr %r0
-	lfd %f2, RETVAL+8(%r1)
-	b .Lfinish
-# case FFI_TYPE_UINT8
-# ifdef __LITTLE_ENDIAN__
-	lbz %r3, RETVAL+0(%r1)
-# else
-	lbz %r3, RETVAL+7(%r1)
-# endif
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_SINT8
-# ifdef __LITTLE_ENDIAN__
-	lbz %r3, RETVAL+0(%r1)
-# else
-	lbz %r3, RETVAL+7(%r1)
-# endif
-	extsb %r3,%r3
-	mtlr %r0
-	b .Lfinish
-# case FFI_TYPE_UINT16
-# ifdef __LITTLE_ENDIAN__
-	lhz %r3, RETVAL+0(%r1)
-# else
-	lhz %r3, RETVAL+6(%r1)
-# endif
-	mtlr %r0
-.Lfinish:
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_SINT16
-# ifdef __LITTLE_ENDIAN__
-	lha %r3, RETVAL+0(%r1)
-# else
-	lha %r3, RETVAL+6(%r1)
-# endif
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_UINT32
-# ifdef __LITTLE_ENDIAN__
-	lwz %r3, RETVAL+0(%r1)
-# else
-	lwz %r3, RETVAL+4(%r1)
-# endif
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_SINT32
-# ifdef __LITTLE_ENDIAN__
-	lwa %r3, RETVAL+0(%r1)
-# else
-	lwa %r3, RETVAL+4(%r1)
-# endif
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_UINT64
-	ld %r3, RETVAL+0(%r1)
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_SINT64
-	ld %r3, RETVAL+0(%r1)
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_TYPE_STRUCT
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-	nop
-# case FFI_TYPE_POINTER
-	ld %r3, RETVAL+0(%r1)
-	mtlr %r0
-	addi %r1, %r1, STACKFRAME
-	blr
-# case FFI_V2_TYPE_FLOAT_HOMOG
-	lfs %f1, RETVAL+0(%r1)
-	lfs %f2, RETVAL+4(%r1)
-	lfs %f3, RETVAL+8(%r1)
-	b .Lmorefloat
-# case FFI_V2_TYPE_DOUBLE_HOMOG
-	lfd %f1, RETVAL+0(%r1)
-	lfd %f2, RETVAL+8(%r1)
-	lfd %f3, RETVAL+16(%r1)
-	lfd %f4, RETVAL+24(%r1)
-	mtlr %r0
-	lfd %f5, RETVAL+32(%r1)
-	lfd %f6, RETVAL+40(%r1)
-	lfd %f7, RETVAL+48(%r1)
-	lfd %f8, RETVAL+56(%r1)
-	addi %r1, %r1, STACKFRAME
-	blr
-.Lmorefloat:
-	lfs %f4, RETVAL+12(%r1)
-	mtlr %r0
-	lfs %f5, RETVAL+16(%r1)
-	lfs %f6, RETVAL+20(%r1)
-	lfs %f7, RETVAL+24(%r1)
-	lfs %f8, RETVAL+28(%r1)
-	addi %r1, %r1, STACKFRAME
-	blr
-.Lsmall:
-# ifdef __LITTLE_ENDIAN__
-	ld %r3,RETVAL+0(%r1)
-	mtlr %r0
-	ld %r4,RETVAL+8(%r1)
-	addi %r1, %r1, STACKFRAME
-	blr
-# else
-	# A struct smaller than a dword is returned in the low bits of r3
-	# ie. right justified.  Larger structs are passed left justified
-	# in r3 and r4.  The return value area on the stack will have
-	# the structs as they are usually stored in memory.
-	cmpldi %r3, FFI_V2_TYPE_SMALL_STRUCT + 7 # size 8 bytes?
-	neg %r5, %r3
-	ld %r3,RETVAL+0(%r1)
-	blt .Lsmalldown
-	mtlr %r0
-	ld %r4,RETVAL+8(%r1)
-	addi %r1, %r1, STACKFRAME
-	blr
-.Lsmalldown:
-	addi %r5, %r5, FFI_V2_TYPE_SMALL_STRUCT + 7
-	mtlr %r0
-	sldi %r5, %r5, 3
-	addi %r1, %r1, STACKFRAME
-	srd %r3, %r3, %r5
-	blr
-# endif
-
-.LFE1:
-	.long	0
-	.byte	0,12,0,1,128,0,0,0
-# if _CALL_ELF == 2
-	.size	ffi_closure_LINUX64,.-ffi_closure_LINUX64
-# else
-#  ifdef _CALL_LINUX
-	.size	ffi_closure_LINUX64,.-.L.ffi_closure_LINUX64
-#  else
-	.size	.ffi_closure_LINUX64,.-.ffi_closure_LINUX64
-#  endif
-# endif
-
-	.section	.eh_frame,EH_FRAME_FLAGS,@progbits
-.Lframe1:
-	.4byte	.LECIE1-.LSCIE1	 # Length of Common Information Entry
-.LSCIE1:
-	.4byte	0x0	 # CIE Identifier Tag
-	.byte	0x1	 # CIE Version
-	.ascii "zR\0"	 # CIE Augmentation
-	.uleb128 0x1	 # CIE Code Alignment Factor
-	.sleb128 -8	 # CIE Data Alignment Factor
-	.byte	0x41	 # CIE RA Column
-	.uleb128 0x1	 # Augmentation size
-	.byte	0x14	 # FDE Encoding (pcrel udata8)
-	.byte	0xc	 # DW_CFA_def_cfa
-	.uleb128 0x1
-	.uleb128 0x0
-	.align 3
-.LECIE1:
-.LSFDE1:
-	.4byte	.LEFDE1-.LASFDE1	 # FDE Length
-.LASFDE1:
-	.4byte	.LASFDE1-.Lframe1	 # FDE CIE offset
-	.8byte	.LFB1-.	 # FDE initial location
-	.8byte	.LFE1-.LFB1	 # FDE address range
-	.uleb128 0x0	 # Augmentation size
-	.byte	0x2	 # DW_CFA_advance_loc1
-	.byte	.LCFI0-.LFB1
-	.byte	0xe	 # DW_CFA_def_cfa_offset
-	.uleb128 STACKFRAME
-	.byte	0x11	 # DW_CFA_offset_extended_sf
-	.uleb128 0x41
-	.sleb128 -2
-	.align 3
-.LEFDE1:
-
-# if defined __ELF__ && defined __linux__
-	.section	.note.GNU-stack,"",@progbits
-# endif
-#endif
diff --git a/testsuite/libffi.call/cls_align_complex.inc b/testsuite/libffi.call/cls_align_complex.inc
deleted file mode 100644
index 4a812ed..0000000
--- a/testsuite/libffi.call/cls_align_complex.inc
+++ /dev/null
@@ -1,91 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <complex.h>
-
-typedef struct cls_struct_align {
-  unsigned char a;
-  _Complex T_C_TYPE b;
-  unsigned char c;
-} cls_struct_align;
-
-cls_struct_align cls_struct_align_fn(
-	struct cls_struct_align a1, struct cls_struct_align a2)
-{
-  struct cls_struct_align result;
-
-  result.a = a1.a + a2.a;
-  result.b = a1.b + a2.b;
-  result.c = a1.c + a2.c;
-
-  printf("%d %f,%fi %d %d %f,%fi %d: %d %f,%fi %d\n",
-	 a1.a, T_CONV creal (a1.b), T_CONV cimag (a1.b), a1.c,
-	 a2.a, T_CONV creal (a2.b), T_CONV cimag (a2.b), a2.c,
-	 result.a, T_CONV creal (result.b), T_CONV cimag (result.b), result.c);
-
-  return  result;
-}
-
-static void
-cls_struct_align_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,
-		    void* userdata __UNUSED__)
-{
-
-  struct cls_struct_align a1, a2;
-
-  a1 = *(struct cls_struct_align*)(args[0]);
-  a2 = *(struct cls_struct_align*)(args[1]);
-
-  *(cls_struct_align*)resp = cls_struct_align_fn(a1, a2);
-}
-
-int main (void)
-{
-  ffi_cif cif;
-  void *code;
-  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
-  void* args_c[5];
-  ffi_type* cls_struct_fields[4];
-  ffi_type cls_struct_type;
-  ffi_type* c_arg_types[5];
-
-  struct cls_struct_align g_c = { 12, 4951 + 7 * I, 127 };
-  struct cls_struct_align f_c = { 1, 9320 + 1 * I, 13 };
-  struct cls_struct_align res_c;
-
-  cls_struct_type.size = 0;
-  cls_struct_type.alignment = 0;
-  cls_struct_type.type = FFI_TYPE_STRUCT;
-  cls_struct_type.elements = cls_struct_fields;
-
-  cls_struct_fields[0] = &ffi_type_uchar;
-  cls_struct_fields[1] = &T_FFI_TYPE;
-  cls_struct_fields[2] = &ffi_type_uchar;
-  cls_struct_fields[3] = NULL;
-
-  c_arg_types[0] = &cls_struct_type;
-  c_arg_types[1] = &cls_struct_type;
-  c_arg_types[2] = NULL;
-
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type,
-		     c_arg_types) == FFI_OK);
-
-  args_c[0] = &g_c;
-  args_c[1] = &f_c;
-  args_c[2] = NULL;
-
-  ffi_call(&cif, FFI_FN(cls_struct_align_fn), &res_c, args_c);
-  /* { dg-output "12 4951,7i 127 1 9320,1i 13: 13 14271,8i 140" } */
-  printf("res: %d %f,%fi %d\n",
-	 res_c.a, T_CONV  creal (res_c.b), T_CONV  cimag (res_c.b), res_c.c);
-  /* { dg-output "\nres: 13 14271,8i 140" } */
-
-  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_struct_align_gn, NULL, code) == FFI_OK);
-
-  res_c = ((cls_struct_align(*)(cls_struct_align, cls_struct_align))(code))(g_c, f_c);
-  /* { dg-output "\n12 4951,7i 127 1 9320,1i 13: 13 14271,8i 140" } */
-  printf("res: %d %f,%fi %d\n",
-	 res_c.a, T_CONV  creal (res_c.b), T_CONV  cimag (res_c.b), res_c.c);
-  /* { dg-output "\nres: 13 14271,8i 140" } */
-
-  exit(0);
-}
diff --git a/testsuite/libffi.call/cls_align_complex_double.c b/testsuite/libffi.call/cls_align_complex_double.c
deleted file mode 100644
index 0dff23a..0000000
--- a/testsuite/libffi.call/cls_align_complex_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Check structure alignment of complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "cls_align_complex.inc"
diff --git a/testsuite/libffi.call/cls_align_complex_float.c b/testsuite/libffi.call/cls_align_complex_float.c
deleted file mode 100644
index 0affbd0..0000000
--- a/testsuite/libffi.call/cls_align_complex_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Check structure alignment of complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "cls_align_complex.inc"
diff --git a/testsuite/libffi.call/cls_align_complex_longdouble.c b/testsuite/libffi.call/cls_align_complex_longdouble.c
deleted file mode 100644
index 7889ba8..0000000
--- a/testsuite/libffi.call/cls_align_complex_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Check structure alignment of complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "cls_align_complex.inc"
diff --git a/testsuite/libffi.call/cls_complex.inc b/testsuite/libffi.call/cls_complex.inc
deleted file mode 100644
index f937404..0000000
--- a/testsuite/libffi.call/cls_complex.inc
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <complex.h>
-
-static void cls_ret_complex_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,
-			      void* userdata __UNUSED__)
- {
-   _Complex T_C_TYPE *pa;
-   _Complex T_C_TYPE *pr;
-   pa = (_Complex T_C_TYPE *)args[0];
-   pr = (_Complex T_C_TYPE *)resp;
-   *pr = *pa;
-
-   printf("%.6f,%.6fi: %.6f,%.6fi\n",
-	  T_CONV creal (*pa), T_CONV cimag (*pa),
-	  T_CONV creal (*pr), T_CONV cimag (*pr));
- }
-typedef _Complex T_C_TYPE (*cls_ret_complex)(_Complex T_C_TYPE);
-
-int main (void)
-{
-  ffi_cif cif;
-  void *code;
-  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
-  ffi_type * cl_arg_types[2];
-  _Complex T_C_TYPE res;
-
-  cl_arg_types[0] = &T_FFI_TYPE;
-  cl_arg_types[1] = NULL;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
-		     &T_FFI_TYPE, cl_arg_types) == FFI_OK);
-
-  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_complex_fn, NULL, code)  == FFI_OK);
-
-  res = (*((cls_ret_complex)code))(0.125 + 128.0 * I);
-  printf("res: %.6f,%.6fi\n", T_CONV creal (res), T_CONV cimag (res));
-  CHECK (res == (0.125 + 128.0 * I));
-
-  exit(0);
-}
diff --git a/testsuite/libffi.call/cls_complex_double.c b/testsuite/libffi.call/cls_complex_double.c
deleted file mode 100644
index 05e3534..0000000
--- a/testsuite/libffi.call/cls_complex_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	closure_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "cls_complex.inc"
diff --git a/testsuite/libffi.call/cls_complex_float.c b/testsuite/libffi.call/cls_complex_float.c
deleted file mode 100644
index 5df7849..0000000
--- a/testsuite/libffi.call/cls_complex_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	closure_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "cls_complex.inc"
diff --git a/testsuite/libffi.call/cls_complex_longdouble.c b/testsuite/libffi.call/cls_complex_longdouble.c
deleted file mode 100644
index 2b1c320..0000000
--- a/testsuite/libffi.call/cls_complex_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	closure_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "cls_complex.inc"
diff --git a/testsuite/libffi.call/cls_complex_struct.inc b/testsuite/libffi.call/cls_complex_struct.inc
deleted file mode 100644
index df8708d..0000000
--- a/testsuite/libffi.call/cls_complex_struct.inc
+++ /dev/null
@@ -1,71 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <complex.h>
-
-typedef struct Cs {
-  _Complex T_C_TYPE x;
-  _Complex T_C_TYPE y;
-} Cs;
-
-Cs gc;
-
-void
-closure_test_fn(Cs p)
-{
-  printf("%.1f,%.1fi %.1f,%.1fi\n",
-	 T_CONV creal (p.x), T_CONV cimag (p.x),
-	 T_CONV creal (p.y), T_CONV cimag (p.y));
-  gc = p;
-}
-
-void
-closure_test_gn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
-		void** args, void* userdata __UNUSED__)
-{
-  closure_test_fn(*(Cs*)args[0]);
-}
-
-int main(int argc __UNUSED__, char** argv __UNUSED__)
-{
-  ffi_cif cif;
-
-  void *code;
-  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
-  ffi_type *cl_arg_types[1];
-
-  ffi_type ts1_type;
-  ffi_type* ts1_type_elements[4];
-
-  Cs arg = { 1.0 + 11.0 * I, 2.0 + 22.0 * I};
-
-  ts1_type.size = 0;
-  ts1_type.alignment = 0;
-  ts1_type.type = FFI_TYPE_STRUCT;
-  ts1_type.elements = ts1_type_elements;
-
-  ts1_type_elements[0] = &T_FFI_TYPE;
-  ts1_type_elements[1] = &T_FFI_TYPE;
-  ts1_type_elements[2] = NULL;
-
-  cl_arg_types[0] = &ts1_type;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
-		     &ffi_type_void, cl_arg_types) == FFI_OK);
-
-  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_gn, NULL, code) == FFI_OK);
-
-  gc.x = 0.0 + 0.0 * I;
-  gc.y = 0.0 + 0.0 * I;
-  ((void*(*)(Cs))(code))(arg);
-  /* { dg-output "1.0,11.0i 2.0,22.0i\n" } */
-  CHECK (gc.x == arg.x && gc.y == arg.y);
-
-  gc.x = 0.0 + 0.0 * I;
-  gc.y = 0.0 + 0.0 * I;
-  closure_test_fn(arg);
-  /* { dg-output "1.0,11.0i 2.0,22.0i\n" } */
-  CHECK (gc.x == arg.x && gc.y == arg.y);
-
-  return 0;
-}
diff --git a/testsuite/libffi.call/cls_complex_struct_double.c b/testsuite/libffi.call/cls_complex_struct_double.c
deleted file mode 100644
index ec71346..0000000
--- a/testsuite/libffi.call/cls_complex_struct_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Check complex arguments in structs.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "cls_complex_struct.inc"
diff --git a/testsuite/libffi.call/cls_complex_struct_float.c b/testsuite/libffi.call/cls_complex_struct_float.c
deleted file mode 100644
index 96fdf75..0000000
--- a/testsuite/libffi.call/cls_complex_struct_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Check complex arguments in structs.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "cls_complex_struct.inc"
diff --git a/testsuite/libffi.call/cls_complex_struct_longdouble.c b/testsuite/libffi.call/cls_complex_struct_longdouble.c
deleted file mode 100644
index 005b467..0000000
--- a/testsuite/libffi.call/cls_complex_struct_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Check complex arguments in structs.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "cls_complex_struct.inc"
diff --git a/testsuite/libffi.call/cls_complex_va.inc b/testsuite/libffi.call/cls_complex_va.inc
deleted file mode 100644
index 8a3e15f..0000000
--- a/testsuite/libffi.call/cls_complex_va.inc
+++ /dev/null
@@ -1,80 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <complex.h>
-
-static _Complex T_C_TYPE gComplexValue1 = 1 + 2 * I;
-static _Complex T_C_TYPE gComplexValue2 = 3 + 4 * I;
-
-static int cls_variadic(const char *format, ...)
-{
-  va_list ap;
-  _Complex T_C_TYPE p1, p2;
-
-  va_start (ap, format);
-  p1 = va_arg (ap, _Complex T_C_TYPE);
-  p2 = va_arg (ap, _Complex T_C_TYPE);
-  va_end (ap);
-
-  return printf(format, T_CONV creal (p1), T_CONV cimag (p1),
-		T_CONV creal (p2), T_CONV cimag (p2));
-}
-
-static void
-cls_complex_va_fn(ffi_cif* cif __UNUSED__, void* resp,
-		  void** args, void* userdata __UNUSED__)
-{
-  char*	format = *(char**)args[0];
-  gComplexValue1 = *(_Complex T_C_TYPE*)args[1];
-  gComplexValue2 = *(_Complex T_C_TYPE*)args[2];
-
-  *(ffi_arg*)resp =
-    printf(format,
-	   T_CONV creal (gComplexValue1), T_CONV cimag (gComplexValue1),
-	   T_CONV creal (gComplexValue2), T_CONV cimag (gComplexValue2));
-}
-
-int main (void)
-{
-  ffi_cif cif;
-  void *code;
-  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
-  void* args[4];
-  ffi_type* arg_types[4];
-  char *format = "%.1f,%.1fi %.1f,%.1fi\n";
-
-  _Complex T_C_TYPE complexArg1 = 1.0 + 22.0 *I;
-  _Complex T_C_TYPE complexArg2 = 333.0 + 4444.0 *I;
-  ffi_arg res = 0;
-
-  arg_types[0] = &ffi_type_pointer;
-  arg_types[1] = &T_FFI_TYPE;
-  arg_types[2] = &T_FFI_TYPE;
-  arg_types[3] = NULL;
-
-  /* This printf call is variadic */
-  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 3, &ffi_type_sint,
-			 arg_types) == FFI_OK);
-
-  args[0] = &format;
-  args[1] = &complexArg1;
-  args[2] = &complexArg2;
-  args[3] = NULL;
-
-  ffi_call(&cif, FFI_FN(cls_variadic), &res, args);
-  printf("res: %d\n", (int) res);
-  CHECK (res == 24);
-
-  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_complex_va_fn, NULL, code)
-	== FFI_OK);
-
-  res = ((int(*)(char *, ...))(code))(format, complexArg1, complexArg2);
-  CHECK (gComplexValue1 == complexArg1);
-  CHECK (gComplexValue2 == complexArg2);
-  printf("res: %d\n", (int) res);
-  CHECK (res == 24);
-
-  exit(0);
-}
diff --git a/testsuite/libffi.call/cls_complex_va_double.c b/testsuite/libffi.call/cls_complex_va_double.c
deleted file mode 100644
index 879ccf3..0000000
--- a/testsuite/libffi.call/cls_complex_va_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Test complex' passed in variable argument lists.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "cls_complex_va.inc"
diff --git a/testsuite/libffi.call/cls_complex_va_float.c b/testsuite/libffi.call/cls_complex_va_float.c
deleted file mode 100644
index 0b79979..0000000
--- a/testsuite/libffi.call/cls_complex_va_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Test complex' passed in variable argument lists.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "cls_complex_va.inc"
diff --git a/testsuite/libffi.call/cls_complex_va_longdouble.c b/testsuite/libffi.call/cls_complex_va_longdouble.c
deleted file mode 100644
index 6eca965..0000000
--- a/testsuite/libffi.call/cls_complex_va_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call, closure_call
-   Purpose:	Test complex' passed in variable argument lists.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "cls_complex_va.inc"
diff --git a/testsuite/libffi.call/complex.inc b/testsuite/libffi.call/complex.inc
deleted file mode 100644
index 515ae3e..0000000
--- a/testsuite/libffi.call/complex.inc
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*-c-*-*/
-#include "ffitest.h"
-#include <complex.h>
-
-static _Complex T_C_TYPE f_complex(_Complex T_C_TYPE c, int x, int *py)
-{
-  c = -(2 * creal (c)) + (cimag (c) + 1)* I;
-  *py += x;
-
-  return c;
-}
-
-int main (void)
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-
-  _Complex T_C_TYPE tc_arg;
-  _Complex T_C_TYPE tc_result;
-  int tc_int_arg_x;
-  int tc_y;
-  int *tc_ptr_arg_y = &tc_y;
-
-  args[0] = &T_FFI_TYPE;
-  args[1] = &ffi_type_sint;
-  args[2] = &ffi_type_pointer;
-  values[0] = &tc_arg;
-  values[1] = &tc_int_arg_x;
-  values[2] = &tc_ptr_arg_y;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3,
-		     &T_FFI_TYPE, args) == FFI_OK);
-
-  tc_arg = 1 + 7 * I;
-  tc_int_arg_x = 1234;
-  tc_y = 9876;
-  ffi_call(&cif, FFI_FN(f_complex), &tc_result, values);
-
-  printf ("%f,%fi %f,%fi, x %d 1234, y %d 11110\n",
-	  T_CONV creal (tc_result), T_CONV cimag (tc_result),
-	  T_CONV creal (2.0), T_CONV creal (8.0), tc_int_arg_x, tc_y);
-
-  CHECK (creal (tc_result) == -2);
-  CHECK (cimag (tc_result) == 8);
-  CHECK (tc_int_arg_x == 1234);
-  CHECK (*tc_ptr_arg_y == 11110);
-
-  exit(0);
-}
diff --git a/testsuite/libffi.call/complex_defs_double.inc b/testsuite/libffi.call/complex_defs_double.inc
deleted file mode 100644
index 3583e16..0000000
--- a/testsuite/libffi.call/complex_defs_double.inc
+++ /dev/null
@@ -1,7 +0,0 @@
-/* -*-c-*- */
-/* Complex base type.  */
-#define T_FFI_TYPE ffi_type_complex_double
-/* C type corresponding to the base type.  */
-#define T_C_TYPE double
-/* C cast for a value of type T_C_TYPE that is passed to printf.  */
-#define T_CONV
diff --git a/testsuite/libffi.call/complex_defs_float.inc b/testsuite/libffi.call/complex_defs_float.inc
deleted file mode 100644
index bbd9375..0000000
--- a/testsuite/libffi.call/complex_defs_float.inc
+++ /dev/null
@@ -1,7 +0,0 @@
-/* -*-c-*- */
-/* Complex base type.  */
-#define T_FFI_TYPE ffi_type_complex_float
-/* C type corresponding to the base type.  */
-#define T_C_TYPE float
-/* C cast for a value of type T_C_TYPE that is passed to printf.  */
-#define T_CONV (double)
diff --git a/testsuite/libffi.call/complex_defs_longdouble.inc b/testsuite/libffi.call/complex_defs_longdouble.inc
deleted file mode 100644
index 14b9f24..0000000
--- a/testsuite/libffi.call/complex_defs_longdouble.inc
+++ /dev/null
@@ -1,7 +0,0 @@
-/* -*-c-*- */
-/* Complex base type.  */
-#define T_FFI_TYPE ffi_type_complex_longdouble
-/* C type corresponding to the base type.  */
-#define T_C_TYPE long double
-/* C cast for a value of type T_C_TYPE that is passed to printf.  */
-#define T_CONV
diff --git a/testsuite/libffi.call/complex_double.c b/testsuite/libffi.call/complex_double.c
deleted file mode 100644
index 8a3297b..0000000
--- a/testsuite/libffi.call/complex_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check complex types.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "complex.inc"
diff --git a/testsuite/libffi.call/complex_float.c b/testsuite/libffi.call/complex_float.c
deleted file mode 100644
index 5044ebb..0000000
--- a/testsuite/libffi.call/complex_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check complex types.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "complex.inc"
diff --git a/testsuite/libffi.call/complex_int.c b/testsuite/libffi.call/complex_int.c
deleted file mode 100644
index 4c8e864..0000000
--- a/testsuite/libffi.call/complex_int.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check non-standard complex types.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "ffitest.h"
-#include "ffi.h"
-#include <complex.h>
-
-_Complex int f_complex(_Complex int c, int x, int *py)
-{
-  c = -(2 * creal (c)) + (cimag (c) + 1)* I;
-  *py += x;
-
-  return c;
-}
-
-/*
- * This macro can be used to define new complex type descriptors
- * in a platform independent way.
- *
- * name: Name of the new descriptor is ffi_type_complex_<name>.
- * type: The C base type of the complex type.
- */
-#define FFI_COMPLEX_TYPEDEF(name, type, ffitype)	     \
-  static ffi_type *ffi_elements_complex_##name [2] = {	     \
-    (ffi_type *)(&ffitype), NULL			     \
-  };							     \
-  struct struct_align_complex_##name {			     \
-    char c;						     \
-    _Complex type x;					     \
-  };							     \
-  ffi_type ffi_type_complex_##name = {		     \
-    sizeof(_Complex type),				     \
-    offsetof(struct struct_align_complex_##name, x),	     \
-    FFI_TYPE_COMPLEX,					     \
-    (ffi_type **)ffi_elements_complex_##name		     \
-  }
-
-/* Define new complex type descriptors using the macro: */
-/* ffi_type_complex_sint */
-FFI_COMPLEX_TYPEDEF(sint, int, ffi_type_sint);
-/* ffi_type_complex_uchar */
-FFI_COMPLEX_TYPEDEF(uchar, unsigned char, ffi_type_uint8);
-
-int main (void)
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-
-  _Complex int tc_arg;
-  _Complex int tc_result;
-  int tc_int_arg_x;
-  int tc_y;
-  int *tc_ptr_arg_y = &tc_y;
-
-  args[0] = &ffi_type_complex_sint;
-  args[1] = &ffi_type_sint;
-  args[2] = &ffi_type_pointer;
-  values[0] = &tc_arg;
-  values[1] = &tc_int_arg_x;
-  values[2] = &tc_ptr_arg_y;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &ffi_type_complex_sint, args)
-	== FFI_OK);
-
-  tc_arg = 1 + 7 * I;
-  tc_int_arg_x = 1234;
-  tc_y = 9876;
-  ffi_call(&cif, FFI_FN(f_complex), &tc_result, values);
-
-  printf ("%d,%di %d,%di, x %d 1234, y %d 11110\n",
-	  (int)tc_result, (int)(tc_result * -I), 2, 8, tc_int_arg_x, tc_y);
-  /* dg-output "-2,8i 2,8i, x 1234 1234, y 11110 11110" */
-  CHECK (creal (tc_result) == -2);
-  CHECK (cimag (tc_result) == 8);
-  CHECK (tc_int_arg_x == 1234);
-  CHECK (*tc_ptr_arg_y == 11110);
-
-  exit(0);
-}
diff --git a/testsuite/libffi.call/complex_longdouble.c b/testsuite/libffi.call/complex_longdouble.c
deleted file mode 100644
index 7e78366..0000000
--- a/testsuite/libffi.call/complex_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check complex types.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "complex.inc"
diff --git a/testsuite/libffi.call/many_complex.inc b/testsuite/libffi.call/many_complex.inc
deleted file mode 100644
index e37a774..0000000
--- a/testsuite/libffi.call/many_complex.inc
+++ /dev/null
@@ -1,78 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-
-#include <stdlib.h>
-#include <complex.h>
-
-static _Complex T_C_TYPE many(_Complex T_C_TYPE c1,
-			      _Complex T_C_TYPE c2,
-			      _Complex T_C_TYPE c3,
-			      _Complex T_C_TYPE c4,
-			      _Complex T_C_TYPE c5,
-			      _Complex T_C_TYPE c6,
-			      _Complex T_C_TYPE c7,
-			      _Complex T_C_TYPE c8,
-			      _Complex T_C_TYPE c9,
-			      _Complex T_C_TYPE c10,
-			      _Complex T_C_TYPE c11,
-			      _Complex T_C_TYPE c12,
-			      _Complex T_C_TYPE c13)
-{
-  printf("0 :%f,%fi\n"
-	 "1 :%f,%fi\n"
-	 "2 :%f,%fi\n"
-	 "3 :%f,%fi\n"
-	 "4 :%f,%fi\n"
-	 "5 :%f,%fi\n"
-	 "6 :%f,%fi\n"
-	 "7 :%f,%fi\n"
-	 "8 :%f,%fi\n"
-	 "9 :%f,%fi\n"
-	 "10:%f,%fi\n"
-	 "11:%f,%fi\n"
-	 "12:%f,%fi\n",
-	 T_CONV creal (c1), T_CONV cimag (c1),
-	 T_CONV creal (c2), T_CONV cimag (c2),
-	 T_CONV creal (c3), T_CONV cimag (c3),
-	 T_CONV creal (c4), T_CONV cimag (c4),
-	 T_CONV creal (c5), T_CONV cimag (c5),
-	 T_CONV creal (c6), T_CONV cimag (c6),
-	 T_CONV creal (c7), T_CONV cimag (c7),
-	 T_CONV creal (c8), T_CONV cimag (c8),
-	 T_CONV creal (c9), T_CONV cimag (c9),
-	 T_CONV creal (c10), T_CONV cimag (c10),
-	 T_CONV creal (c11), T_CONV cimag (c11),
-	 T_CONV creal (c12), T_CONV cimag (c12),
-	 T_CONV creal (c13), T_CONV cimag (c13));
-
-  return (c1+c2-c3-c4+c5+c6+c7-c8-c9-c10-c11+c12+c13);
-}
-
-int main (void)
-{
-  ffi_cif cif;
-  ffi_type *args[13];
-  void *values[13];
-  _Complex T_C_TYPE ca[13];
-  _Complex T_C_TYPE c, cc;
-  int i;
-
-  for (i = 0; i < 13; i++)
-    {
-      args[i] = &T_FFI_TYPE;
-      values[i] = &ca[i];
-      ca[i] = i + (-20 - i) * I;
-    }
-
-    /* Initialize the cif */
-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, &T_FFI_TYPE, args) == FFI_OK);
-
-    ffi_call(&cif, FFI_FN(many), &c, values);
-
-    cc =  many(ca[0], ca[1], ca[2], ca[3], ca[4], ca[5], ca[6], ca[7], ca[8],
-	       ca[9], ca[10], ca[11], ca[12]);
-    CHECK(creal (cc) == creal (c));
-    CHECK(cimag (cc) == cimag (c));
-
-    exit(0);
-}
diff --git a/testsuite/libffi.call/many_complex_double.c b/testsuite/libffi.call/many_complex_double.c
deleted file mode 100644
index 3fd53c3..0000000
--- a/testsuite/libffi.call/many_complex_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex, with many arguments
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "many_complex.inc"
diff --git a/testsuite/libffi.call/many_complex_float.c b/testsuite/libffi.call/many_complex_float.c
deleted file mode 100644
index c43d21c..0000000
--- a/testsuite/libffi.call/many_complex_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex, with many arguments
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "many_complex.inc"
diff --git a/testsuite/libffi.call/many_complex_longdouble.c b/testsuite/libffi.call/many_complex_longdouble.c
deleted file mode 100644
index dbab723..0000000
--- a/testsuite/libffi.call/many_complex_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex, with many arguments
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "many_complex.inc"
diff --git a/testsuite/libffi.call/return_complex.inc b/testsuite/libffi.call/return_complex.inc
deleted file mode 100644
index 8bf0c1f..0000000
--- a/testsuite/libffi.call/return_complex.inc
+++ /dev/null
@@ -1,37 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <complex.h>
-
-static _Complex T_C_TYPE return_c(_Complex T_C_TYPE c)
-{
-  printf ("%f,%fi\n", T_CONV creal (c), T_CONV cimag (c));
-  return 2 * c;
-}
-int main (void)
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-  _Complex T_C_TYPE c, rc, rc2;
-  T_C_TYPE cr, ci;
-
-  args[0] = &T_FFI_TYPE;
-  values[0] = &c;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
-		     &T_FFI_TYPE, args) == FFI_OK);
-
-  for (cr = -127.0; cr <  127; cr++)
-    {
-      ci = 1000.0 - cr;
-      c = cr + ci * I;
-      ffi_call(&cif, FFI_FN(return_c), &rc, values);
-      rc2 = return_c(c);
-      printf ("%f,%fi vs %f,%fi\n",
-	      T_CONV creal (rc), T_CONV cimag (rc),
-	      T_CONV creal (rc2), T_CONV cimag (rc2));
-      CHECK(rc == 2 * c);
-    }
-  exit(0);
-}
diff --git a/testsuite/libffi.call/return_complex1.inc b/testsuite/libffi.call/return_complex1.inc
deleted file mode 100644
index 7cecc0f..0000000
--- a/testsuite/libffi.call/return_complex1.inc
+++ /dev/null
@@ -1,41 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <complex.h>
-
-static _Complex T_C_TYPE return_c(_Complex T_C_TYPE c1, float fl2, unsigned int in3, _Complex T_C_TYPE c4)
-{
-  return c1 + fl2 + in3 + c4;
-}
-int main (void)
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-  _Complex T_C_TYPE c1, c4, rc, rc2;
-  float fl2;
-  unsigned int in3;
-  args[0] = &T_FFI_TYPE;
-  args[1] = &ffi_type_float;
-  args[2] = &ffi_type_uint;
-  args[3] = &T_FFI_TYPE;
-  values[0] = &c1;
-  values[1] = &fl2;
-  values[2] = &in3;
-  values[3] = &c4;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
-		     &T_FFI_TYPE, args) == FFI_OK);
-  c1 = 127.0 + 255.0 * I;
-  fl2 = 128.0;
-  in3 = 255;
-  c4 = 512.7 + 1024.1 * I;
-
-  ffi_call(&cif, FFI_FN(return_c), &rc, values);
-  rc2 = return_c(c1, fl2, in3, c4);
-  printf ("%f,%fi vs %f,%fi\n",
-	  T_CONV creal (rc), T_CONV cimag (rc),
-	  T_CONV creal (rc2), T_CONV cimag (rc2));
-  CHECK(rc == rc2);
-  exit(0);
-}
diff --git a/testsuite/libffi.call/return_complex1_double.c b/testsuite/libffi.call/return_complex1_double.c
deleted file mode 100644
index 727410d..0000000
--- a/testsuite/libffi.call/return_complex1_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "return_complex1.inc"
diff --git a/testsuite/libffi.call/return_complex1_float.c b/testsuite/libffi.call/return_complex1_float.c
deleted file mode 100644
index a2aeada..0000000
--- a/testsuite/libffi.call/return_complex1_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "return_complex1.inc"
diff --git a/testsuite/libffi.call/return_complex1_longdouble.c b/testsuite/libffi.call/return_complex1_longdouble.c
deleted file mode 100644
index 103504b..0000000
--- a/testsuite/libffi.call/return_complex1_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "return_complex1.inc"
diff --git a/testsuite/libffi.call/return_complex2.inc b/testsuite/libffi.call/return_complex2.inc
deleted file mode 100644
index dad4a0f..0000000
--- a/testsuite/libffi.call/return_complex2.inc
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*-c-*- */
-#include "ffitest.h"
-#include <complex.h>
-
-static _Complex T_C_TYPE return_c(_Complex T_C_TYPE c1, _Complex T_C_TYPE c2, unsigned int in3, _Complex T_C_TYPE c4)
-{
-  return c1 + c2 + in3 + c4;
-}
-int main (void)
-{
-  ffi_cif cif;
-  ffi_type *args[MAX_ARGS];
-  void *values[MAX_ARGS];
-  _Complex T_C_TYPE c1, c2, c4, rc, rc2;
-  unsigned int in3;
-  args[0] = &T_FFI_TYPE;
-  args[1] = &T_FFI_TYPE;
-  args[2] = &ffi_type_uint;
-  args[3] = &T_FFI_TYPE;
-  values[0] = &c1;
-  values[1] = &c2;
-  values[2] = &in3;
-  values[3] = &c4;
-
-  /* Initialize the cif */
-  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
-		     &T_FFI_TYPE, args) == FFI_OK);
-  c1 = 127.0 + 255.0 * I;
-  c2 = 128.0 + 256.0;
-  in3 = 255;
-  c4 = 512.7 + 1024.1 * I;
-
-  ffi_call(&cif, FFI_FN(return_c), &rc, values);
-  rc2 = return_c(c1, c2, in3, c4);
-  printf ("%f,%fi vs %f,%fi\n",
-	  T_CONV creal (rc), T_CONV cimag (rc),
-	  T_CONV creal (rc2), T_CONV cimag (rc2));
-  CHECK(rc ==  c1 + c2 + in3 + c4);
-  exit(0);
-}
diff --git a/testsuite/libffi.call/return_complex2_double.c b/testsuite/libffi.call/return_complex2_double.c
deleted file mode 100644
index ab9efac..0000000
--- a/testsuite/libffi.call/return_complex2_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "return_complex2.inc"
diff --git a/testsuite/libffi.call/return_complex2_float.c b/testsuite/libffi.call/return_complex2_float.c
deleted file mode 100644
index d7f22c2..0000000
--- a/testsuite/libffi.call/return_complex2_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "return_complex2.inc"
diff --git a/testsuite/libffi.call/return_complex2_longdouble.c b/testsuite/libffi.call/return_complex2_longdouble.c
deleted file mode 100644
index 3edea62..0000000
--- a/testsuite/libffi.call/return_complex2_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "return_complex2.inc"
diff --git a/testsuite/libffi.call/return_complex_double.c b/testsuite/libffi.call/return_complex_double.c
deleted file mode 100644
index e2497cc..0000000
--- a/testsuite/libffi.call/return_complex_double.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_double.inc"
-#include "return_complex.inc"
diff --git a/testsuite/libffi.call/return_complex_float.c b/testsuite/libffi.call/return_complex_float.c
deleted file mode 100644
index a35528f..0000000
--- a/testsuite/libffi.call/return_complex_float.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_float.inc"
-#include "return_complex.inc"
diff --git a/testsuite/libffi.call/return_complex_longdouble.c b/testsuite/libffi.call/return_complex_longdouble.c
deleted file mode 100644
index 142d7be..0000000
--- a/testsuite/libffi.call/return_complex_longdouble.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Area:	ffi_call
-   Purpose:	Check return value complex.
-   Limitations:	none.
-   PR:		none.
-   Originator:	<vogt@linux.vnet.ibm.com>.  */
-
-/* { dg-do run } */
-
-#include "complex_defs_longdouble.inc"
-#include "return_complex.inc"
